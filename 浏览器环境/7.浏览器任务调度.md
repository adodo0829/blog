# 浏览器任务调度

浏览器下存在事件，用户交互，js 脚本，ui 渲染，网络请求等任务, 浏览器采用了事件循环的方式来调度这些任务

## 动画渲染 API

1.从任务队列中取出一个宏任务并执行。

2.检查微任务队列，执行并清空微任务队列，如果在微任务的执行中又加入了新的微任务，也会在这一步一起执行。

进入更新渲染阶段，判断是否需要渲染，这里有一个 rendering opportunity 的概念，也就是说不一定每一轮 event loop 都会对应一次浏览 器渲染，要根据屏幕刷新率、页面性能、页面是否在后台运行来共同决定，通常来说这个渲染间隔是固定的。（所以多个 task 很可能在一次渲染之间执行）

浏览器会尽可能的保持帧率稳定，例如页面性能无法维持 60fps（每 16.66ms 渲染一次）的话，那么浏览器就会选择 30fps 的更新速率，而不是偶尔丢帧。
如果浏览器上下文不可见，那么页面会降低到 4fps 左右甚至更低。
如果满足以下条件，也会跳过渲染：

浏览器判断更新渲染不会带来视觉上的改变。
map of animation frame callbacks 为空，也就是帧动画回调为空，可以通过 requestAnimationFrame 来请求帧动画。

如果上述的判断决定本轮不需要渲染，那么下面的几步也不会继续运行：

对于需要渲染的文档，如果窗口的大小发生了变化，执行监听的 resize 方法。

对于需要渲染的文档，如果页面发生了滚动，执行 scroll 方法。

对于需要渲染的文档，执行帧动画回调，也就是 requestAnimationFrame 的回调。

对于需要渲染的文档， 执行 IntersectionObserver 的回调。

对于需要渲染的文档，重新渲染绘制用户界面。

判断 task 队列和 microTask 队列是否都为空，如果是的话，则进行 Idle 空闲周期的算法，判断是否要执行 requestIdleCallback 的回调函数。


## requestAnimationFrame
- 在重新渲染前调用。
- 很可能在宏任务之后不调用(任务合并)。

rAF 是官方推荐的用来做一些流畅动画所应该使用的 API，做动画不可避免的会去更改 DOM，而如果在渲染之后再去更改 DOM，
那就只能等到下一轮渲染机会的时候才能去绘制出来了，这显然是不合理的。
rAF在浏览器决定渲染之前给你最后一个机会去改变 DOM 属性，然后很快在接下来的绘制中帮你呈现出来，所以这是做流畅动画的不二选择

## requestIdleCallback
把一些计算量较大但是又没那么紧急的任务放到空闲时间去执行。不要去影响浏览器中优先级较高的任务，比如动画绘制、用户输入等

## 小结
事件循环不一定每轮都伴随着重渲染，但是如果有微任务，一定会伴随着微任务执行。
决定浏览器视图是否渲染的因素很多，浏览器是非常聪明的。
requestAnimationFrame在重新渲染屏幕之前执行，非常适合用来做动画。
requestIdleCallback在渲染屏幕之后执行，并且是否有空执行要看浏览器的调度，如果你一定要它在某个时间内执行，请使用 timeout参数。
resize和scroll事件其实自带节流，它只在 Event Loop 的渲染阶段去派发事件到 EventTarget 上。
