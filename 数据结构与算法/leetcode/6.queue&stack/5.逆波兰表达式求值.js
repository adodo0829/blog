/**
 * 根据 逆波兰表示法，求表达式的值。
有效的运算符包括 + ,  - ,  * ,  / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

说明：
整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

输入: ["2", "1", "+", "3", " * "]
解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

输入: ["4", "13", "5", "/", "+"]
解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6

输入: ["10", "6", "9", "3", "+", "-11", " * ", "/", " * ", "17", "+", "5", "+"]
((10 * (6 / ((9 + 3) * -11))) + 17) + 5  
 */

// 数: n个,  运算符 n-1个
// 逆波兰表示法 =》 后缀表达式，所谓后缀就是指运算符写在后面
// 遇到两数字, a,b入栈, 遇到运算符(a 符号 b)...

// 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。

var evalRPN = function (tokens) {
  const isToken = (t) => ["+", "-", "*", "/"].includes(t);
  const stack = [];
  const fnMap = {
    "+": (a, b) => a + b,
    "-": (a, b) => a - b,
    "*": (a, b) => a * b,
    "/": (a, b) => (a / b) | 0, // 取整技巧 === v >= 0 ? Math.floor(v) : Math.ceil(v)
  };

  for (let i = 0; i < tokens.length; i++) {
    const item = tokens[i];

    if (!isToken(item)) {
      stack.push(item);
    } else {
      const n1 = +stack.pop();
      const n2 = +stack.pop(); // 先进栈的, 在前面, 注意除法的运算顺序
      let res = fnMap[item](n2, n1);
      stack.push(res);
    }
  }

  // 每次都只有两个数再做运算
  return stack.pop();
};
