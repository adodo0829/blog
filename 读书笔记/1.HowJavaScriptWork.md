# How JavaScript Work

## 1.v8引擎(解析,编译器), 运行时, 调用堆栈
```
- 内存堆管理 memory heap, 内存分配

- 调用栈 call stack
 - 入口
 - 数量1个, 单线程, 和Web相关线程通信

- 运行时
 - js + webAPI共同协作
 - 事件循环和任务队列
```
## 2.V8下 js优化点
对象属性的顺序：总是以相同的顺序实例化对象属性，这样隐藏类及之后的优化代码都可以被共享。
动态属性：实例化之后为对象添加属性会致使为之前隐藏类优化的方法变慢。相反，在对象构造函数中赋值对象的所有属性。
方法：重复执行相同方法的代码会比每次运行不同的方法的代码更快(多亏了内联缓存)。
数列：避免使用键不是递增数字的稀疏数列。稀疏数列中没有包含每个元素的数列称为一个哈希表。访问该数列中的元素会更加耗时。
     同样地，试着避免预先分配大型数组。最好是随着使用而递增。最后，不要删除数列中的元素。这会让键稀疏。

## 3.内存管理
- 静态和动态分配内存  
  一是时间不同。静态分配发生在程序编译和连接的时候。动态分配则发生在程序调入和执行的时候。
  二是空间不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由函数malloc进行分配.
  malloc函数的原型为：void *malloc (unsigned int size) 其作用是在内存的动态存储区中分配一个长度为size的连续空间。其参数是一个无符号整形数，返回值是一个指向所分配的连续存储域的起始地址的指针

- 标记-清除算法包含三个步骤：
  根：一般来说，根指的是代码中引用的全局变量。就拿 JavaScript 来说，window 对象即是根的全局变量。Node.js 中相对应的变量为 "global"。垃圾回收器会构建出一份所有根变量的完整列表。
  随后，算法会检测所有的根变量及他们的后代变量并标记它们为激活状态(表示它们不可回收)。任何根变量所到达不了的变量(或者对象等等)都会被标记为内存垃圾。
  最后，垃圾回收器会释放所有非激活状态的内存片段然后返还给操作系统。

  解决循环引用

- 内存泄漏
  全局变量、
  定时器 & 被遗忘的回调函数、

