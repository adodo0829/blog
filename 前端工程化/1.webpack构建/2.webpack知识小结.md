# webpack读书小结
本篇主要是针对 webpack 文档的读书笔记, 以目录的形式展现, 旨在对 webpack 有个全局的了解...使用的时候不至于那么陌生emm...持续更新中ing

## webpack简介
学一个知识点或者某一领域的内容, 遵守这个`知识点`是什么(what); 为什么用它(why); 怎么用它(how); 什么场景下用它(who); 使用时候的注意事项,坑点(when),当然这是事后总结...这是我一贯的学习习惯
- 1.webpack是什么(what)
```
webpack: js模块打包工具, 可以把各个存在依赖关系的模块,
按照特定的规则和顺序组织在一起,最终输出为一个JS文件(或者多个)
```
- 2.webpack的使用场景(who)
```
应用: 大型项目由多个文件模块组成, 当模块代码依赖过多时, 手动引入不利于维护
webpack 可以将多个模块按照依赖关系自动打包, 维护方便, 提升项目开发效率
```
- 3.webpack怎么用(how)
```shell
# 我们选择在项目全部安装 webpack
yarn init
yarn add webpack webpack-cli -D
# 创建打包入口文件index.js
# 创建打包配置文件webpack.config.js
# 更多配置项见官方文档
module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js'
  },
  module: 'development',
  devServer: {
    publicPath: '/dist'
  }
}
# 在 package.json中定义脚本命令
{
  "script": {
    "build": "webpack",
    "dev": "webpack-dev-server"
  }
}
```
- 4.为啥用webpack(why)
```
1.Webpack默认支持多种模块标准,包括AMD、CommonJS，以及ESModule
2.Webpack有完备的代码分割（code splitting）解决方案, 异步加载(jsonp)
3.Webpack可以处理各种类型的资源, 丰富的 loader 插件
4.Webpack 生态圈比较完善, 很多踩过的坑已经被别人踩了
```
## 模块简介
这里主要介绍一下主流的模块化标准: CommonJS 规范和 ESModule 规范, 以及他们的特性
- CommonJS规范  
js文件即模块
```
作用域: 模块内部本身

导出: 模块内部有个 moudle 对象(记录每个模块的状态), 有个exports属性,用来导出
     module.exports(他也是一个引用) = {}, 
     或者exports.xxx = ooo(exports引用module.exports)

导入: require('./module.js')
     require(): 它是一个函数, 执行()中的路径参数, 从而去执行路径模块文件的内容
     再次调用(module.loaded = true): 直接去上次调用后缓存的结果
```
- ESModule规范
他是js语言级别的特性,有特定关键字语法实现,在解析编译时确定模块(引用);
同样也是文件即模块, 默认严格模式
```
作用域: 模块自身

导出: export 语法
     具名导出: export const name = 'huhua', export 变量, export { name as 改个名导出 }
     默认导出: export defalut 你想导出的变量或者确定值; 模块挂载 default 属性上

导入: import 语法
     导入具名模块: import { name } from './info.js'
     导入默认模块: import Name from './infoDefault.js'
     整体导入(当模块导出多个变量时): import * as ModuleObj from './info.js'
     复合导入: import XXX, { ooo } from 'module'
     ...不说了
     自执行导入: import './autoDo.js'
```
- 二者的区别
```
1.加载方式:
  CommonJS: 在代码运行时去查找,运行模块依赖文件(动态的)
  ESModule: 在代码解析,编译阶段查找模块依赖文件(静态的, 针对这一特性: 便有了tree shaking等一系列优化措施) 

2.导入结果:
  CommonJS: 导入的是一个模块执行结果的拷贝
  ESModule: 导入的是一个模块属性的只读引用

3.循环依赖解决: 项目太大时, 代码可能存在隐式的模块依赖循环引用
  比如: a.js依赖b.js, b.js又依赖a.js
  CommonJS: 执行逻辑: a -> b(引入a: 直接导出a,未执行完: 空{}, 继续执行b) -> b 执行完在执行 a
  解决: 模块是值拷贝, 无法解决, 只能提前返回一个{}
  ESModule: 执行逻辑: a -> b(引入a: 直接导出a,未执行完: undefined, 继续执行b) -> b 执行完在执行 a
  解决: 因为模块是动态引用, 利用这个特性可以解决
```
- UMD: 通用模块标准, 根据执行环境运行模块
```js
(function (global, main) {
  if (typeof define === 'function' && define.amd) {
    // AMD module
    define(fn())
  } else if (typeof exports === 'object') {
    // commonjs module
    module.exports = { fn }
  } else {
    // 浏览器环境
    global.fn = fn
  }
})(this, function() { return { /*模块 */ } })
```
- npm 模块  
npm: js 的工具包管理器
```shell
# 初始化项目
npm init -y
# 安装包
npm install package
# 这些包会被安装在 node_modules 文件夹下, 在项目导入是会去自动搜索
# 每个 package 在自己的 package.json 下又有一个入口 main: 'name.js'
```
- webpack模块打包结果大致结构
```js
(function (modules) {
  var installedModules = {} // 缓存已加载模块

  // 模块加载函数
  function __webpack__require__(moduleId) {
    // 判断即将加载的模块是否存在于installedModules中
    // 如果存在则直接取值, 不存在则去获取module.exports的值
  }

  // 执行入口模块
  return __webpack__require__(__webpack__require__.s = 0)
})(
  // 模块对象集合
  {
    0: function(module, exports, __webpack__require__) {
      // 打包的入口
      module.exports = __webpack__require__('1') // 下一个模块的 id
    },
    1: function(module, exports, __webpack__require__) {
      // 模块 1 逻辑
    },
    2: function(module, exports, __webpack__require__) {
      // 模块 2 逻辑
    },
    // ...
  }
)
```