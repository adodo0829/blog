# js 中其他内置对象

## 正则对象 regExp
### 表达式
```
var reg = /pattern/g
var reg = new RegExp('pattern','g')

g:表示全局(global)模式
即模式将被应用于所有字符串，而并非在发现第一个匹配项时立即停止

i:表示不区分大小写(case-insensitive)模式
即在确定匹配项时忽略模式与字符串的大小写

m:表示多行(multiline)模式
即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项
```
### 匹配模式: pattern
#### 元字符
| 元字符         |名称              |匹配对象|
|:|:|:|:|
| .             |点号               |单个任意字符(除回车\r、换行\n、行分隔符\u2028和段分隔符\u2029外)|
| []            |字符组             |列出的单个任意字符|
| [^]           |排除型字符组        |未列出的单个任意字符|
| ?             |问号               |匹配0次或1次|
| *             |星号               |匹配0次或多次|
| +             |加号               |匹配1次或多次|
| {min,max}     |区间量词            |匹配至少min次，最多max次|
| ^             |脱字符             |行的起始位置|
| $             |美元符             |行的结束位置|
| |             |竖线               |分隔两边的任意一个表达式|
| ()            |括号               |限制多选结构的范围，标注量词作用的元素，为反向引用捕获文本|
| \1,\2...      |反向引用            |匹配之前的第一、第二...组括号内的表达式匹配的文本|
#### 转义字符\
转义字符(escape)表示为 `\被转译字符` 的形式.
```
1.转译元字符
console.log(/\*/.test('*')); // true

2.特殊符号
\'	单引号
\"	双引号
\&	和号
\\	反斜杠
\n	换行符
\r	回车符
\t	制表符
\b	退格符
\f	换页符

3.双重转译 \/
/name\/age/.test('name/age') true
```
####  字符组[]
用方括号表示的一组字符，它匹配若干字符之一, 单个字符
```
# 范围 -
/[0-9]/.test('1') true
# 排除 [^] 表示在当前位置匹配一个没有列出的字符 
/[^0-9]/.test('1') false
# 简写
\d     数字，等同于[0-9]
\D     非数字，等同于[^0-9]
\s     空白字符，等同于[\f\n\r\t\u000B\u0020\u00A0\u2028\u2029]
\S     非空白字符，等同于[^\f\n\r\t\u000B\u0020\u00A0\u2028\u2029]
\w     字母、数字、下划线，等同于[0-9A-Za-z_](汉字不属于\w)
\W     非字母、数字、下划线，等同于[^0-9A-Za-z_]
# 任意字符 /[\s\S]/ || /[\w\W]/ || /[\d\D]/
console.log(/[\s\S]/.test('\r')) true
```
#### 量词
```
{n}       匹配n次
{n,m}     匹配至少n次，最多m次
{n,}      匹配至少n次
?         相当于{0,1}
*         相当于{0,}
+         相当于{1,}

/\d{3}/ 匹配 3 位数字
/https?/  http和https两种协议

# 默认贪婪模式: 匹配到下一个字符不满足匹配规则为止
# 非贪婪模式: 量词后加问号'?'表示，表示尽可能少的匹配，一旦条件满足就再不往下匹配
```
#### 分组和引用 ()
分组: 括号里的表达式，被称为子表达式
/\w{1,64}@([-a-zA-z0-9]{1,63}\.)+[-a-zA-Z0-9]{1,63}/

捕获: 括号不仅可以对元素进行分组，还会保存每个分组匹配的文本，
等到匹配完成后，引用捕获的内容。因为捕获了文本，这种功能叫捕获分组
```
/(\d{4})-(\d{2})-(\d{2})/  年、月、日
RegExp.$1\RegExp.$2\RegExp.$3……到RegExp.$9分别用于存储第一、第二……第九个匹配的捕获组。
在调用exec()或test()方法时，这些属性会被自动填充
console.log(/(\d{4})-(\d{2})-(\d{2})/.test('2016-06-23'));//true
console.log(RegExp.$1);//'2016'
console.log(RegExp.$2);//'06'
console.log(RegExp.$3);//'23'
console.log(RegExp.$4);//''

捕获分组捕获的文本，不仅可以用于数据提取，也可以用于替换
console.log('2000-01-01'.replace(/(\d{4})-(\d{2})-(\d{2})/g,'$3-$2-$1'));//'01-01-2000'

反向引用: 允许在正则表达式内部引用之前捕获分组匹配的文本，形式是\num，num表示所引用分组的编号
// 检测重复字母
/([a-z])\1/
console.log(/([a-z])\1/.test('aa'));//true
console.log(/([a-z])\1/.test('ab'));//false

// 检测成对标签
/<([^>]+)>[\s\S]*?<\/\1>/
```
#### 选择 |

#### 断言 ^ $
```
1.单词边界 \b
console.log(/\ban\b/.test('an'));//true
console.log(/\ban\b/.test('and'));//false

2.起始位置
^和$，它们分别匹配字符串的开始位置和结束位置
function trim(str){
    return str.replace(/^\s+|\s+$/, '')
}  
console.log(trim('   hello world   '));//'hello world'

环视: (?=n): 表示前面必须是n才匹配
console.log(/a(?=b)/.exec('abc'));//['a']
console.log(/a(?=b)/.exec('ac'));//null
console.log(/a(?!b)/.exec('abc'));//null
console.log(/a(?!b)/.exec('ac'));//['a']
```
### 优先级
//从上到下，优先级逐渐降低

```
\                            转义符
() (?!) (?=) []              括号、字符组、环视
* + ? {n} {n,} {n,m}         量词
^ $                          起始结束位置
|                            选择
```
### 实例方法
exec()
```
找出匹配的所有位置和所有值
var string = 'j1h342jg24g234j 3g24j1';
var pattern = /\d/g;
var valueArray = []; // 值
var indexArray = []; // 位置
var temp;
while((temp=pattern.exec(string)) != null){
    valueArray.push(temp[0]);
    indexArray.push(temp.index);  
}
// valueArray => indexArray
["1", "3", "4", "2", "2", "4", "2", "3", "4", "3", "2", "4", "1"]
[1, 3, 4, 5, 8, 9, 11, 12, 13, 16, 18, 19, 21]
```
