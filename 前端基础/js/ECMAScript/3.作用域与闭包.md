# 作用域和闭包
总的来说可以分为以下几块内容区理解: 
```
词法作用域
动态作用域 (动态作用域与this机制挂钩)
全局作用域
函数作用域
块级作用域
```
## 前言基础
我们先了解下js引擎(解释器/编译器结构), js引擎可以理解为根据ECMAScript定义的语言标准来动态执行JavaScript字符串...[js 引擎基础](https://hijiangtao.github.io/2018/06/17/Shapes-ICs/)  
整个解析过程可分为: `语法检查阶段` -> `运行时阶段`
#### 语法检查阶段(一)
语法检查阶段: 分为 词法分析和语法分析
```
JS解释器先把JavaScript代码（字符串）的字符流按照ECMAScript标准转换为记号流,
分解为词法单元块. 
// 比如 var a = 2, 词法分析后的结果
[
  "var": "keyword",
  "a": "identifier",
  "=": "assignment",
  "2": "integer",
  ";": "eos" (end of statement)
]
// 然后根据解析的词法结构结合标准与法生成 AST
{
  operation: "=",
  left: {
    keyword: "var",
    right: "a"
  }
  right: "2"
}
// 遍历这颗抽象语法树(其中的一些操作还没去深入研究, 反正可以做很多事情, 什么eslint, babel 转化等),
最后直接会转化为机器指令(分配内存空间)

# 当语法检查出现错误时, 会抛出错误...
```
#### 运行时阶段(二)
运行时阶段: 预解析 和 代码执行
- 先预解析(一)
```
# 1.创建执行上下文环境: 先是全局, 然后是函数,会被依次push到执行栈(一块内存来管理上下文)
// 上下文环境包括: 
变量对象VO: 优先级依次是 arguments声明, function声明, var声明
作用域链Scope: 由当前变量对象以及上层父级作用域构成的一条链表结构, 便于变量查询
this值:    表示当前上下文对象, 程序进入上下文就会确定下来

# 2.为上下文中的变量对象(VO)赋值
函数形参: undefined
函数声明: 如果变量对象已经包含了相同名字的属性，则会替换它的值, 
         此时函数的标识符在环境中已存在(变量提升的原因)
变量声明: undefined
// 例子就不举了...QAQ
```
- 再代码执行(二)
```
进入执行代码阶段
预解析阶段的初始化属性:
  `变量对象`的undefined值可能会被覆盖 => 变为活动对象(AO)
  `作用域链`可能会改变
  `this值`也可能会改变
```

## 作用域
作用域: 可以理解为`变量的生命周期,有效范围`; 也可以理解为js中用来`访问变量`的一套规则...

#### 词法作用域
上面为甚么提到 js引擎解析代码的过程, 因为语法检查阶段可以看做是理解词法作用域的基础;
词法作用域就是定义在词法阶段的作用域, `JavaScript采用的是词法作用域`, 变量,函数的作用域在函数定义的时候就决定
> 词法作用域只由变量,函数被声明时所处的位置决定
```
// 第一层
var a = 1
function foo(a) {
  // 第二层
  var b = a * 2;
  function bar(c) {
    // 第三层
    console.log(a, b, c);
  }
  bar(b * 3);
}
foo(2) // 2, 4, 12
分析一下: 这里有个嵌套的作用域
第一层: 全局作用域, 两个声明, foo, a
第二层: foo的函数作用域, 三个声明, a, b, bar
第三层: bar的函数作用域, 一个声明, c

作用域的这种嵌套结构和互相之间的位置关系给 js 引擎提供了的位置信息;
js引擎可以用这些信息来查找标识符声明的位置;

特性: 作用域查找从运行时所处的最内部作用域开始，逐级向上进行，直到遇见第一个匹配的标识符为止
```

#### 动态作用域
动态作用域主要是js程序在运行时决定的, 与 this 机制相关; 动态作用域并不关心函数和作用域是如何声明以及在任何处声明的,只关心`它从何处调用`...
> 函数的作用域是在函数调用的时候才决定, 与上下文挂钩

## 作用域链
当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。
作用域链在函数创建和运行时是会发生改变的...
#### 函数创建时
