/**
 * Solid原则: S, O, L, I, D
 */

/**
 * 单一职责S: 一个类或者模块只负责完成一个职责（或者功能）
 * 设计的粒度要细
 * 如何判定: 类的属性和方法控制, 属性和私有方法数量 => 代码行数
 */

/**
 * 开闭O: 对扩展开放、对修改关闭
 * 怎么定义是 扩展还是修改
 * 可以粗略的理解为: 添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等）,
 *                而非修改已有代码（修改模块、类、方法等）
 * 扩展意识、抽象意识、封装意识, 不变的部分和可变的部分
 */

/**
 * 里式替换L: 用来指导继承关系中子类该如何设计的一个原则
 * 核心: 按照协议来设计, 父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。
 * 这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。
 */

/**
 * 接口隔离I: 单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口(API, 函数, OOP接口)的设计，另一方面它的思考角度也是不同的。
 * 接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。
 * 如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。
 */

/**
 * 依赖反转D: 用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象
 * 控制反转: 控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。
 *         在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。
 * 依赖注入: 依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，
 *         而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。
 *      
 */

// DRY原则: repeat: 逻辑重复, 语义重复, 执行重复
// 提高代码可复用性: 
// 减少代码耦合
// 满足单一职责原则
// 模块化
// 业务与非业务逻辑分离
// 通用代码下沉
// 继承、多态、抽象、封装
// 应用模板等设计模式

/**
 * 高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中, 修改会比较集中，代码容易维护
 * 松耦合，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动
 */

/**
 * 业务系统设计
 * 需求分析, 系统代码设计, 上线维护
 * 
 * 1.需求分析: 
 *          竞品分析,借鉴, 借助线框图、用户用例（user case）或者叫用户故事（user story）来细化业务流程,
 *          具备产品思维(基于用户)
 * 
 * 2.系统设计: 
 *          1.合理的将功能划分到不同模块中
 *          2.设计模块之间的交互关系 (解耦)
 *          3.接口设计, 数据库设计, 业务模型设计
 * 
 * 3.测试部署,上线维护
 */