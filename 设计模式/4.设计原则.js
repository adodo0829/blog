/**
 * Solid原则: S, O, L, I, D
 */

/**
 * 单一职责S: 一个类或者模块只负责完成一个职责（或者功能）
 * 设计的粒度要细
 * 如何判定: 类的属性和方法控制, 属性和私有方法数量 => 代码行数
 */

/**
 * 开闭O: 对扩展开放、对修改关闭
 * 怎么定义是 扩展还是修改
 * 可以粗略的理解为: 添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等）,
 *                而非修改已有代码（修改模块、类、方法等）
 * 扩展意识、抽象意识、封装意识, 不变的部分和可变的部分
 */

/**
 * 里式替换L: 用来指导继承关系中子类该如何设计的一个原则
 * 核心: 按照协议来设计, 父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。
 * 这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。
 */

/**
 * 接口隔离I: 单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口(API, 函数, OOP接口)的设计，另一方面它的思考角度也是不同的。
 * 接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。
 * 如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。
 */

/**
 * 依赖反转:
 */